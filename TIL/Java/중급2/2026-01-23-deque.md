# 2026-01-23: 스택, 큐, 데크 (Stack, Queue, Deque)

- 📚 **강의**: 김영한의 자바 중급2 섹션 10

오늘은 선형 자료구조인 스택, 큐와 이를 모두 대체할 수 있는 강력한 인터페이스인 **Deque(데크)**에 대해 학습했다.

## 1. Stack (사용 금지 🚫)

- LIFO (Last In First Out): 나중에 넣은 것이 먼저 나온다.
- **문제점**: 자바 초기(1.0)에 만들어진 클래스로, 성능이 좋지 않은 `Vector`를 상속받는다. (동기화로 인한 성능 저하)
- **결론**: 실무에서 `Stack` 클래스는 **절대 사용하지 않는다.** 대신 `Deque` 인터페이스를 사용하자.

```java
Stack<Integer> stack = new Stack<>(); 
stack.push(1); // 데이터 추가
int value = stack.pop(); // 데이터 꺼내기 (LIFO)
```

## 2. Queue (큐)

- FIFO (First In First Out): 먼저 넣은 것이 먼저 나온다. (대기열 등)
- 주요 메서드:
    - `offer(e)`: 데이터 추가
    - `poll()`: 데이터 꺼내기
    - `peek()`: 데이터 확인 (꺼내지 않음)

## 3. Deque (Double Ended Queue)

양쪽 끝에서 데이터를 넣고 뺄 수 있는 만능 자료구조다. **스택과 큐의 기능을 모두 가지고 있다.**

### 주요 메서드
- **데이터 추가**: `offerFirst()` (앞), `offerLast()` (뒤)
- **데이터 꺼내기**: `pollFirst()` (앞), `pollLast()` (뒤)
- **데이터 확인**: `peekFirst()` (앞), `peekLast()` (뒤)

> 참고: `push()`는 `addFirst()`와, `pop()`은 `removeFirst()`와 동일하게 동작하여 스택처럼 쓸 수 있게 해준다.

### ArrayDeque vs LinkedList
자바에서 `Deque`의 구현체는 크게 두 가지다.
1.  **ArrayDeque**: 내부적으로 배열 사용.
2.  **LinkedList**: 내부적으로 Node 연결 사용.

> **💡 추천**: 대부분의 경우 **ArrayDeque**가 더 빠르다.
> - **메모리**: `LinkedList`처럼 노드 객체를 따로 만들 필요가 없어 메모리를 덜 쓴다.
> - **성능**: 배열은 메모리 상에 연속적으로 위치하므로 **CPU 캐시 효율(Locality)**이 좋다. 반면 `LinkedList`는 메모리 곳곳에 흩어져 있어 캐시 히트율이 낮다.

### 사용 예제 (Stack & Queue 대용)

```java
// ArrayDeque를 스택처럼 사용
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.push(2);
stack.pop(); // 2

// ArrayDeque를 큐처럼 사용
Deque<Integer> queue = new ArrayDeque<>();
queue.offer(1);
queue.offer(2);
queue.poll(); // 1
```
