# 2026-01-22: 해시 알고리즘 (Hash Algorithm)

- 📚 **강의**: 김영한의 자바 중급2 섹션 7 Hash

오늘은 데이터 검색 성능을 획기적으로 높여주는 **해시(Hash)** 개념과 **해시 인덱스**, 그리고 필연적으로 발생하는 **해시 충돌**을 해결하는 방법에 대해 학습했다.

## 1. 해시 인덱스 (Hash Index)

일반적인 배열 검색은 앞에서부터 하나씩 찾아야 하므로 **O(N)**의 시간이 걸린다. 데이터가 많아질수록 느려진다.
하지만 **데이터의 값 자체를 인덱스로 사용**한다면?

- **원리**: `저장할 값 % 배열 크기` = `인덱스`
- **효과**: 값만 알면 배열의 어느 위치에 있는지 즉시 알 수 있다. 검색 속도가 **O(1)**로 매우 빨라진다.

```java
// 해시 인덱스 구하기
int value = 14;
int index = value % 10; // 4
buckets[index] = value;
```

## 2. 해시 충돌 (Hash Collision)

서로 다른 값을 저장하는데, 해시 연산 결과(인덱스)가 우연히 같을 수 있다. (예: `1 % 10 = 1`, `11 % 10 = 1`) 이를 **해시 충돌**이라고 한다.

### 해결: 체이닝 (Chaining)
가장 일반적인 해결 방법은 배열의 각 인덱스에 값이 아니라 **연결 리스트(LinkedList)**를 두는 것이다.
- 같은 인덱스에 데이터가 들어오면, 해당 인덱스의 리스트에 노드를 추가한다.
- **검색 과정**:
    1.  해시 인덱스로 버킷(리스트)을 찾는다. (O(1))
    2.  리스트 내부를 순회하며 값을 찾는다. (데이터가 적으므로 빠름)

```java
// 체이닝 구현 예시
LinkedList<Integer>[] buckets = new LinkedList[10]; // 배열 안에 리스트

public void add(int value) {
    int index = value % 10;
    LinkedList<Integer> bucket = buckets[index]; // O(1)
    
    // 중복 체크 후 추가
    if (!bucket.contains(value)) {
        bucket.add(value);
    }
}
```

## 3. 성능 (Big-O)

해시 알고리즘은 **데이터의 분포**에 따라 성능이 좌우된다.

- **평균 (잘 분포됨)**: 충돌이 적어서 리스트 길이가 짧다. -> **O(1)**
- **최악 (모두 충돌)**: 모든 데이터가 하나의 인덱스(리스트)에 몰린다. -> **O(N)**

하지만 적절한 해시 함수와 배열 크기를 사용하면 대부분 O(1)에 가까운 성능을 낸다.
