# 2026-01-20: Java 연결 리스트 (LinkedList)

- 📚 **강의**: 김영한의 자바 중급2 섹션 4

오늘은 배열의 인덱스 대신, 노드(Node)들의 연결을 통해 데이터를 관리하는 **LinkedList**에 대해 학습했다.

## 1. 노드와 연결 구조

LinkedList의 핵심은 **노드(Node)**라는 객체다.
```java
class Node {
    Object item; // 저장할 데이터
    Node next;   // 다음 노드를 가리키는 참조(주소)
}
```
- 데이터들이 메모리상에 연속적으로 위치하지 않고, 서로 떨어진 노드들이 `next` 참조를 통해 연결(Link)되어 있다.
- **장점**: 배열처럼 미리 공간을 확보할 필요가 없다. 데이터가 추가될 때마다 노드만 생성해서 연결하면 된다.

## 2. LinkedList 구현 (MyLinkedList)

직접 구현해보며 알게 된 핵심 연산 방식이다.
- **추가**: 새로운 노드를 만들고, 마지막 노드의 `next`가 새 노드를 가리키게 한다.
- **중간 삽입/삭제**: 삽입/삭제할 위치의 **이전 노드**를 찾아서 `next` 참조만 변경하면 된다. 배열처럼 데이터를 대량으로 이동(Shift)시킬 필요가 없다.

### 성능 (Big-O)

| 연산 | 시간 복잡도 | 설명 |
| :--- | :--- | :--- |
| **인덱스 조회** (`get`) | **O(N)** | 인덱스로 바로 접근 불가. 첫 노드부터 순서대로 찾아가야 함 (치명적 단점) |
| **앞/뒤에 추가** (`addFirst`, `addLast`) | **O(1)** | 첫/마지막 노드의 참조를 유지하면 즉시 추가 가능 |
| **중간 추가/삭제** (`add(index, ..)`) | **O(N)** | 위치를 찾는 데 O(N) 시간이 걸림. (단, 위치를 알고 있다면 연결 변경은 O(1)) |
| **순차 검색** (`indexOf`) | **O(N)** | 데이터를 하나씩 확인해야 함 |

## 3. ArrayList vs LinkedList 비교

| 특징 | ArrayList (배열) | LinkedList (노드 연결) |
| :--- | :--- | :--- |
| **데이터 접근 (Read)** | **매우 빠름 O(1)** | 느림 O(N) |
| **데이터 추가 (Write)** | 끝에 추가: 빠름<br>중간 추가: 느림 O(N) (밀기) | 끝/앞 추가: 빠름<br>중간 추가: 빠름 (단, 위치 찾기는 O(N)) |
| **메모리 효율** | 데이터 크기만큼 사용 (+ 여유 공간) | 노드 객체 생성 비용 및 `next` 참조 공간 추가 소모 |

> **💡 결론**:
> - **대부분의 경우**: **ArrayList**가 성능(조회)과 메모리 효율 면에서 더 좋다.
> - **데이터를 앞에서 추가/삭제하거나, 중간 삽입/삭제가 매우 잦은 경우**: **LinkedList**를 고려해볼 수 있다.
