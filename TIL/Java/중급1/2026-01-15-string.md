# 2026-01-15: Java String 클래스 학습

- 📚 **강의**: 김영한의 자바 중급1 섹션 4

오늘은 자바에서 가장 많이 사용되는 클래스인 **String** 클래스의 구조와 성능 최적화 기법(`StringBuilder`), 그리고 메서드 체이닝 패턴에 대해 학습했다.

## 1. String 기본

`String`은 기본형(Primitive)이 아니라 **참조형(Reference)**이다. 하지만 워낙 자주 사용되기에 리터럴 표기법(`"Hello"`)을 지원하여 기본형처럼 편리하게 사용할 수 있다.

- **내부 구조**:
    - 과거(Java 8 이하): `char[]`
    - 최신(Java 9 이상): `byte[]` + 인코딩 정보 (메모리 효율 최적화)

## 2. 문자열 비교 (Comparison)

`String` 비교 시 가장 중요한 원칙은 **"항상 `equals()`를 사용하라"**이다. 그 이유는 **문자열 생성 방식**에 따라 `==` 연산(동일성 비교)의 결과가 달라지기 때문이다.

### 문자열 풀 (String Pool)
자바는 메모리 효율을 위해 문자열 리터럴(`"Hello"`)을 **문자열 풀**이라는 힙 영역 내 특수한 공간에 저장해두고 재사용한다.

### 비교 케이스 분석

```java
String str1 = "Hello"; // 리터럴 생성 (문자열 풀 사용)
String str2 = "Hello"; // 리터럴 생성 (풀에서 조회, 재사용)
String str3 = new String("Hello"); // 객체 생성 (힙 영역에 별도 생성)
String str4 = new String("Hello"); // 객체 생성 (힙 영역에 별도 생성)

// 1. 리터럴 vs 리터럴 (== true)
System.out.println(str1 == str2); 
// 둘 다 문자열 풀의 같은 참조값을 가리킴.

// 2. 리터럴 vs new String (== false)
System.out.println(str1 == str3); 
// str1은 풀, str3는 힙 영역의 인스턴스. 참조값이 다름.

// 3. new String vs new String (== false)
System.out.println(str3 == str4); 
// 서로 다른 인스턴스이므로 참조값이 다름.

// 4. equals 비교 (항상 true)
System.out.println(str1.equals(str3));
System.out.println(str3.equals(str4));
// 참조값이 달라도 문자열 내용("Hello")이 같으므로 모두 true.
```

- **`==` (동일성)**: 참조값(메모리 주소)을 비교한다. 리터럴끼리는 같을 수 있지만, `new`나 조합된 문자열은 다를 수 있다. 너무 변수가 많다.
- **`equals()` (동등성)**: 문자열의 **내용(Content)**을 비교한다. 어떤 방식으로 생성되었든 내용만 같으면 `true`를 보장한다.

## 3. 불변성 (Immutability)

`String`은 **불변 객체**다. 한 번 생성된 문자열은 변경할 수 없다.

- **문제점**: 문자열을 더하는 연산(`+`)을 수행하면, 내부 값이 바뀌는 게 아니라 **새로운 String 객체**가 생성된다.
- **성능 이슈**: 루프 안에서 문자를 계속 더하면(`"A" + "B" + ...`) 수많은 임시 객체(Garbage)가 생성되어 시스템 성능이 급격히 저하된다. ($O(N^2)$)

## 4. 주요 메서드 (Methods)

자주 사용되는 `String` 메서드들을 기능별로 정리했다.

- **문자열 정보 조회**
    - `length()`: 문자열 길이 반환
    - `isEmpty()`: 길이가 0인지 확인
    - `isBlank()`: 길이가 0이거나 공백(Whitespace)만 있는지 확인 (Java 11+)
    - `charAt(int index)`: 특정 인덱스의 문자 반환

- **문자열 비교**
    - `equals(Object anObject)`: 내용 비교
    - `equalsIgnoreCase(String anotherString)`: 대소문자 무시하고 내용 비교
    - `compareTo(String anotherString)`: 사전적 순서 비교
    - `startsWith(String prefix)`, `endsWith(String suffix)`: 시작/끝 문자열 확인

- **문자열 검색**
    - `contains(CharSequence s)`: 특정 문자열 포함 여부
    - `indexOf(String str)`: 특정 문자열이 시작되는 인덱스 반환 (없으면 -1)
    - `lastIndexOf(String str)`: 뒤에서부터 검색

- **문자열 조작 및 변환**
    - `substring(int beginIndex, int endIndex)`: 부분 문자열 추출 (endIndex 제외)
    - `concat(String str)`: 문자열 결합
    - `replace(CharSequence target, CharSequence replacement)`: 문자열 대치
    - `toLowerCase()`, `toUpperCase()`: 소문자/대문자 변환
    - `trim()`, `strip()`: 공백 제거 (`strip`이 최신, 유니코드 공백 지원)

- **분할과 조합**
    - `split(String regex)`: 구분자로 분리하여 배열로 반환
    - `join(CharSequence delimiter, CharSequence... elements)`: 배열/리스트를 구분자로 결합

- **기타 유틸리티**
    - `valueOf(Object obj)`: 다양한 타입을 문자열로 변환 (static 메서드)
    - `toCharArray()`: 문자 배열로 변환

## 5. StringBuilder

가변(Mutable) 문자열 객체다. 내부 버퍼(`byte[]`)를 직접 변경하므로, 문자열 연산 시 새로운 객체를 생성하지 않는다.

### 등장 배경 (String의 단점)
불변인 `String` 클래스의 단점은 문자를 더하거나 변경할 때마다 **계속해서 새로운 객체를 생성해야 한다**는 점이다.
- 문자를 자주 더하거나 변경하는 상황이라면 무수히 많은 `String` 객체가 생성되고, 이를 CG(Garbage Collection)해야 한다.
- 결과적으로 **CPU와 메모리 자원을 낭비**하게 된다.
- 문자열의 크기가 클수록, 변경이 잦을수록 시스템 자원 소모가 심각해진다.

이러한 문제를 해결하기 위해, 내부 값을 변경할 수 있는 가변 `StringBuilder`가 등장했다.

```java
StringBuilder sb = new StringBuilder();
sb.append("A");
sb.append("B");
sb.append("C");
String result = sb.toString(); // "ABC"
```

- **사용 시점**: 문자열 변경이나 연산이 빈번할 때, 특히 **반복문(Loop) 안에서** 필수다.

## 6. 메서드 체이닝 (Method Chaining)

메서드가 **자기 자신(`this`)을 반환**하여, 점(`.`)을 찍고 연속적으로 메서드를 호출할 수 있게 하는 기법이다.

```java
// 일반적인 방식
adder.add(1);
adder.add(2);
adder.add(3);

// 메서드 체이닝
adder.add(1).add(2).add(3);
```

### StringBuilder 활용 예제
`StringBuilder`의 주요 메서드들(`append`, `insert`, `delete`, `reverse` 등)은 모두 `this`(자기 자신)를 반환하도록 설계되어 있다. 덕분에 복잡한 문자열 조작을 한 줄로 깔끔하게 처리할 수 있다.

```java
StringBuilder sb = new StringBuilder();
String string = sb.append("A").append("B").append("C").append("D")
        .insert(4, "Java")
        .delete(4, 8)
        .reverse()
        .toString();

System.out.println("string = " + string);
```

- **장점**: 코드가 간결해지고 가독성이 좋아진다. 만약 체이닝이 없었다면 `sb.append(...); sb.insert(...); ...` 처럼 여러 줄에 걸쳐 작성해야 했을 것이다.
