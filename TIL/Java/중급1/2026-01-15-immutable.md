# 2026-01-15: Java 불변 객체(Immutable Object) 학습

- 📚 **강의**: 김영한의 자바 중급1 섹션 3

오늘은 객체의 값을 생성 이후에 변경할 수 없는 **불변 객체**에 대해 학습했다. 여러 변수가 하나의 객체를 공유할 때 발생할 수 있는 부작용(Side Effect)을 예방하는 핵심 기술이다.

## 1. 기본형 vs 참조형 공유

- **기본형 (Primitive Type)**: 값을 대입하면 값이 복사되어 들어간다. (`int b = a`)
    - `a`를 변경해도 `b`에는 영향이 없다.
- **참조형 (Reference Type)**: 값을 대입하면 **참조값(주소)**이 복사되어 들어간다.
    - `Address b = a`를 하면 `a`와 `b`는 같은 인스턴스를 바라본다.
    - **공유 참조** 문제가 발생할 수 있다.

## 2. 공유 참조와 사이드 이펙트 (Side Effect)

객체를 공유하는 것 자체는 문제가 아니지만, 공유된 객체의 값을 변경할 때 문제가 발생한다.

```java
Address a = new Address("서울");
Address b = a; // 참조값 공유

b.setValue("부산"); // b의 값을 변경했는데
System.out.println(a.getValue()); // a의 값도 "부산"으로 바뀜!
```

- **사이드 이펙트**: 의도치 않게 다른 부분에 영향을 주는 현상.
- **문제점**:
  - 코드상에서 `b.setValue()`만 호출했기 때문에, `a`의 값이 바뀔 것이라고 예측하기 힘들다.
  - 디버깅이 매우 어렵다.

## 3. 불변 객체 (Immutable Object)

공유 참조 문제를 해결하는 가장 확실한 방법은 **"객체의 값을 아예 변경하지 못하게 막는 것"**이다.

```java
public class ImmutableAddress {
    private final String value; // final로 값 변경 방지

    public ImmutableAddress(String value) {
        this.value = value;
    }
    // setValue() 없음! (Setter 제거)
}
```

- **특징**: 생성자를 통해서만 값을 설정할 수 있고, 이후에는 값을 바꿀 수 없다.
- **효과**: `b = a`로 공유해도, `b`의 값을 바꿀 수 없으므로 `a`에 영향을 줄 수 없다. 사이드 이펙트가 원천 차단된다.

## 4. 불변 객체의 값 변경

불변 객체의 값을 변경하고 싶다면? **값을 변경하는 것이 아니라, 새로운 객체를 만들어서 반환해야 한다.**

```java
public class ImmutableObj {
    private final int value;

    public ImmutableObj add(int addValue) {
        // 내 값을 바꾸는게 아니라, 결과를 담은 "새로운 객체"를 반환
        return new ImmutableObj(this.value + addValue);
    }
}
```

- **사용법**: 반환된 값을 받아야 한다.
    - `obj.add(10);` (X) -> 반환값을 버리면 아무 일도 안 일어난 것과 같다.
    - `obj = obj.add(10);` (O) -> 새로운 객체로 갈아타야 한다.

### 참고 - withXxx() 관례
불변 객체에서 값을 변경하는 메서드는 주로 `with`로 시작하는 이름을 사용한다. (예: `withYear()`)
- **의미**: "커피에 설탕을 더해(with sugar) 새로운 변형을 만든다"는 뉘앙스처럼, **원본을 유지한 채 변경사항을 포함한 새 인스턴스를 반환함**을 뜻한다.
- **장점**: 메서드 이름만 보고도 "아, 이 메서드는 객체 상태를 바꾸는 게 아니라 새 객체를 주는구나"라고 예측할 수 있다.

## 5. 불변 객체 사용 기준과 장점

**모든 클래스를 불변으로 만드는 것은 아니다.**

- **가변 (Mutable)**: 대부분의 경우(예: `Member` 등 속성이 변해야 하는 엔티티)는 가변으로 설계한다.
- **불변 (Immutable)**: 값을 변경하면 안 되는 특별한 경우(`Address`, `Money` 등 값 타입)에 사용한다.
- 때로는 같은 기능을 하는 클래스를 불변/가변으로 각각 만들어 사용하기도 한다.

### 불변 객체 설계 이유
1.  **캐시 안정성**: 값이 변하지 않으므로 안심하고 캐싱할 수 있다.
2.  **멀티 쓰레드 안정성**: 여러 쓰레드에서 동시에 접근해도 값이 변하지 않아 동기화 문제가 발생하지 않는다. (Thread-safe)
3.  **엔티티의 값 타입**: DB 엔티티 내에서 임베디드 타입 등으로 사용할 때 안전하다.
