# 2026-01-27: 스레드 동기화 (synchronized)

- 📚 **강의**: 김영한의 자바 고급1 섹션 7

오늘은 멀티스레드 환경에서 데이터 정합성을 지키기 위한 핵심 개념인 **임계 영역**과 **synchronized** 키워드, 그리고 그 한계에 대해 학습했다.

## 1. 임계 영역 (Critical Section)

여러 스레드가 동시에 접근하면 안 되는 공유 자원(주로 인스턴스 변수)에 접근하는 코드 영역을 말한다. 이를 보호하지 않으면 데이터가 꼬이는 동시성 문제가 발생한다.

> **참고**: 지역 변수(Local Variable)는 스레드마다 개별적인 스택 공간에 생성되므로 동기화 걱정이 없다. 공유되는 **필드(멤버 변수)**가 문제다.

## 2. synchronized 키워드

자바는 `synchronized` 키워드를 통해 간단하게 락(Lock)을 획득하고 반납하는 기능을 제공한다.

### 2-1. 메서드 동기화
메서드 전체에 락을 건다. 사용이 편하지만, 메서드 내용이 길면 불필요한 부분까지 막혀 성능이 저하될 수 있다.
```java
public synchronized void method() {
    // ...
}
```

### 2-2. 블록 동기화 (권장 ✅)
꼭 필요한 부분만 감싸서 락을 건다. 성능 최적화에 유리하다.
```java
public void method() {
    // ... 동기화 필요 없는 코드 ...
    synchronized (this) {
        // ... 임계 영역 ...
    }
    // ... 동기화 필요 없는 코드 ...
}
```

## 3. synchronized의 한계

`synchronized`는 편리하지만 몇 가지 치명적인 단점이 있다.

1.  **무한 대기 (Infinite Waiting)**
    -   `BLOCKED` 상태가 되면 락을 얻을 때까지 하염없이 기다린다.
    -   타임아웃(Timeout) 설정이 불가능하다. (시스템이 멈춘 것처럼 보일 수 있음)
2.  **공정성 문제 (Fairness)**
    -   락이 풀렸을 때, 대기 중인 여러 스레드 중 누가 락을 가져갈지 순서가 보장되지 않는다.

## 4. 해결책: java.util.concurrent (자바 1.5+)

이러한 `synchronized`의 문제를 해결하기 위해 자바 1.5부터 `java.util.concurrent` 패키지가 도입되었다. (`Lock`, `ReentrantLock` 등)

> **💡 결론**:
> 단순하고 편리한 방법이 필요하다면 `synchronized`를 쓰고,
> 타임아웃이나 정교한 제어가 필요하다면 `java.util.concurrent` 기능을 사용하자.
