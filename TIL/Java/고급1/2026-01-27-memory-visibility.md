# 2026-01-27: 메모리 가시성 (Memory Visibility)

- 📚 **강의**: 김영한의 자바 고급1 섹션 6

오늘은 멀티스레드 환경에서 발생하는 심각한 버그 중 하나인 **메모리 가시성 문제**와 이를 해결하는 `volatile`, 그리고 **자바 메모리 모델(JMM)**에 대해 학습했다.

## 1. 메모리 가시성 문제 (Memory Visibility Problem)

컴퓨터는 성능을 높이기 위해 CPU 캐시 메모리(L1, L2...)를 사용한다. 하지만 멀티스레드 환경에서는 이것이 독이 될 수 있다.

1.  **Main Thread**가 `runFlag`를 `false`로 변경한다. (Main Memory에 반영됨)
2.  **Task Thread**는 자신의 **CPU 캐시**에 있는 `runFlag`(`true`)만 계속 읽는다.
3.  **결과**: Main Memory의 변경 사항이 Task Thread의 캐시까지 전파되지 않아, 루프가 끝나지 않는다.

> **가시성(Visibility)**: 한 스레드가 변경한 값이 다른 스레드에게 잘 보이는가?

## 2. 해결사: volatile 키워드

변수 선언 시 `volatile`을 붙이면 **캐시 메모리를 사용하지 않고, 항상 메인 메모리(Main Memory)에 직접 읽고 쓰게 된다.**

```java
// 선언 방법
volatile boolean runFlag = true;
```

-   **장점**: 확실한 **가시성 보장**. (언제나 최신 값을 읽음)
-   **단점**: 캐시를 안 쓰므로 **성능 저하**가 발생할 수 있다. (필요한 곳에만 써야 함)
-   **주의**: 원자성(Atomicity)은 보장하지 않는다. (`count++` 같은 복합 연산은 동기화 필요)

> **💡 핵심 요약**:
> 메모리 가시성 문제는 **`volatile`** 또는 **스레드 동기화 기법(`synchronized`, `ReentrantLock`)**을 사용하면 발생하지 않는다.
> (동기화 블록을 들어가고 나갈 때 메모리 동기화가 자동으로 이루어지기 때문)

## 3. 자바 메모리 모델 (Java Memory Model, JMM)

JMM은 자바가 멀티스레드 환경에서 메모리에 접근하는 규칙을 정의한 표준이다. 이것 덕분에 OS나 하드웨어가 달라도 자바 프로그램은 일관되게 동작한다.

### 핵심: Happens-Before 관계
**"A 작업은 B 작업보다 무조건 먼저 실행되어야 한다(메모리에 보여야 한다)"**는 규칙. JVM은 이 규칙을 지키는 한에서 성능 최적화를 위해 명령 순서를 바꿀 수 있다.

-   **volatile 변수 규칙**: volatile 변수에 대한 **쓰기(write)**는 그 이후의 모든 **읽기(read)**보다 먼저 일어난다. (즉, 쓰면 바로 읽을 수 있다)
-   **Lock 규칙**: 락을 푸는 것(unlock)은 나중에 락을 얻는 것(lock)보다 먼저 일어난다.
-   **Thread start/join 규칙**: `thread.start()` 호출 전의 작업은 스레드 내부에서 다 보인다.
