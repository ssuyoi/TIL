# 2026-01-07: Java 생성자(Constructor) 학습

- 📚 **강의**: 김영한의 자바 기본 섹션 5

오늘은 객체를 생성하고 초기화하는 가장 안전하고 효율적인 방법인 **생성자(Constructor)**에 대해 학습했다. 초기화 메서드의 번거로움을 해결하고 필수 데이터를 보장하는 방법을 이해했다.

## 1. 생성자가 필요한 이유

객체를 생성하고 나면 보통 초기값을 할당해야 한다. 초기화 메서드(`initMember`)를 만들어 해결할 수 있지만, 몇 가지 단점이 있다.
- **번거로움**: 객체 생성(`new`) 후 반드시 초기화 메서드를 별도로 호출해야 한다.
- **누락 위험**: 실수로 초기화 메서드를 호출하지 않으면, 데이터가 없는 상태(유령 객체)로 프로그램이 동작할 수 있다.

이러한 문제를 해결하기 위해, 객체 생성 시점에 자동으로 호출되는 **생성자**를 사용한다.

## 2. 생성자 (Constructor)

객체가 생성될 때(`new`) **딱 한 번** 호출되는 특별한 메서드다.

### 규칙
- 이름이 **클래스 이름과 같아야** 한다.
- **반환 타입이 없다** (void도 적지 않는다).
- 그 외에는 일반 메서드와 같다.

### 기본 생성자 (Default Constructor)
- 생성자를 하나도 작성하지 않으면, 자바 컴파일러가 매개변수와 내용이 없는 기본 생성자를 자동으로 만들어준다.
- **주의**: 생성자를 하나라도 직접 만들면 기본 생성자는 자동 생성되지 않는다.

## 3. this 키워드

인스턴스 자신의 멤버 변수에 접근할 때 사용한다.
주로 매개변수와 멤버 변수의 이름이 같을 때, 이를 구분하기 위해 사용한다.

```java
// 멤버 변수(name)와 매개변수(name)의 이름이 같음
public void method(String name) {
    this.name = name; // this.name은 멤버 변수를 가리킴
}
```

> **참고**: 이름이 다르다면 `this`를 생략해도 되지만, 최근 스타일은 구분을 위해 명시적으로 적지 않는 추세다. (IDE가 색상으로 구분해주기 때문)

## 4. 생성자 오버로딩과 this()

### 생성자 오버로딩
매개변수를 다르게 하여 여러 개의 생성자를 정의할 수 있다. 이를 통해 다양한 방식으로 객체를 생성할 수 있다.

### this()
생성자 내부에서 **자신의 다른 생성자**를 호출할 때 사용한다. 생성자 코드가 중복되는 것을 방지할 수 있다.
- **규칙**: `this()`는 반드시 **생성자 코드의 첫 줄**에만 작성할 수 있다.

```java
public Member(String name, int age) {
    this(name, age, 50); // 다른 생성자 호출 (grade 기본값 50)
}

public Member(String name, int age, int grade) {
    this.name = name;
    this.age = age;
    this.grade = grade;
}
```
